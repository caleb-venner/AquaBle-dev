import { WRGB_PRO_II_WATTAGE_DATA, ChannelWattageData } from './wattage-data';

export interface ChannelPercentages {
  red: number;
  green: number;
  blue: number;
  white: number;
}

export interface WattageCalculationResult {
  totalWattage: number;
  channelWattages: {
    red: number;
    green: number;
    blue: number;
    white: number;
  };
  stepSum: number;
  embeddedBaseSum: number;
  sharedBase: number;
  requestedWattage: number; // What the channels would use without power limiting
  powerLimited: boolean; // Whether power limiting was applied
}

/**
 * Calculates the step wattage for a single channel based on its percentage
 * Uses floor lookup: finds the largest percentage in step table â‰¤ input percentage
 */
function calculateChannelStepWattage(channel: 'Red' | 'Green' | 'Blue' | 'White', percentage: number): number {
    if (percentage === 0) return 0;

    const data = WRGB_PRO_II_WATTAGE_DATA[channel];
    if (!data) return 0;

    // Find exact match first
    for (let i = 0; i < data.Percentage.length; i++) {
        const stepPercentage = parseInt(data.Percentage[i].replace('%', ''));
        if (stepPercentage === percentage) {
            return data.Wattage[i];
        }
    }

    // Find the floor step (largest step <= percentage)
    let floorIndex = -1;
    for (let i = 0; i < data.Percentage.length; i++) {
        const stepPercentage = parseInt(data.Percentage[i].replace('%', ''));
        if (stepPercentage <= percentage) {
            floorIndex = i;
        } else {
            break; // Stop when we exceed the target percentage
        }
    }

    // Handle edge cases
    if (floorIndex === -1) {
        return data.Wattage[0]; // Below first point, use first value
    }

    return data.Wattage[floorIndex]; // Use floor step value
}

const BASE_VALUE_COEF = {
  Red: 0.62,
  Green: 0.87,
  Blue: 0.40,
  White: 0.50,
  Total: 2.39
};


function calculateBase(red: number, green: number, blue: number, white: number): number {
  const redOn = red > 0;
  const greenOn = green > 0;
  const blueOn = blue > 0;
  const whiteOn = white > 0;
  const numOn = (redOn ? 1 : 0) + (greenOn ? 1 : 0) + (blueOn ? 1 : 0) + (whiteOn ? 1 : 0);


  let numCoef: number = (redOn ? red/100 : 0) + (greenOn ? green/100 : 0) +
                  (blueOn ? blue/100 : 0) + (whiteOn ? white/100 : 0)/4;

  /*
  let sharedBase: number = ((redOn ? BASE_VALUE_COEF.Red*9 : 0) + (greenOn ? BASE_VALUE_COEF.Green : 0) +
                      (blueOn ? BASE_VALUE_COEF.Blue : 0) + (whiteOn ? BASE_VALUE_COEF.White : 0) );
   */

  let sharedBase: number = ((redOn ? BASE_VALUE_COEF.Red : 0) + (greenOn ? BASE_VALUE_COEF.Green : 0) +
                      (blueOn ? BASE_VALUE_COEF.Blue : 0) + (whiteOn ? BASE_VALUE_COEF.White : 0))/BASE_VALUE_COEF.Total;
  return  numCoef - numOn*(9 - sharedBase);
}


export function calculateLightWattage(channels: ChannelPercentages): WattageCalculationResult {
  const { red, green, blue, white } = channels;

  const redOn = red > 0;
  const greenOn = green > 0;
  const blueOn = blue > 0;
  const whiteOn = white > 0;
  const activeChannels = [redOn, greenOn, blueOn, whiteOn].filter(Boolean).length;

  if (activeChannels === 0) {
    return {
      totalWattage: 0,
      channelWattages: { red: 0, green: 0, blue: 0, white: 0 },
      stepSum: 0,
      embeddedBaseSum: 0,
      sharedBase: 0,
      requestedWattage: 0,
      powerLimited: false,
    };
  }

  // Get step wattages from lookup tables (true single-channel values using floor logic)
  const stepWattages = {
    red: redOn ? calculateChannelStepWattage('Red', red) : 0,
    green: greenOn ? calculateChannelStepWattage('Green', green) : 0,
    blue: blueOn ? calculateChannelStepWattage('Blue', blue) : 0,
    white: whiteOn ? calculateChannelStepWattage('White', white) : 0
  };

  let requestedWattage: number;
  const stepSum = stepWattages.red + stepWattages.green + stepWattages.blue + stepWattages.white;

  /* // For single channels, use step wattage directly (no embedded base manipulation) **********************************
  if (activeChannels === 1) {
    requestedWattage = stepSum; // Just the single channel's step wattage

    // Apply 138W power limiting
    const MAX_TOTAL_WATTAGE = 138;
    const totalWattage = Math.min(Math.round(requestedWattage), MAX_TOTAL_WATTAGE);
    const powerLimited = requestedWattage > MAX_TOTAL_WATTAGE;

    return {
      totalWattage,
      channelWattages: {
        red: redOn ? totalWattage : 0,
        green: greenOn ? totalWattage : 0,
        blue: blueOn ? totalWattage : 0,
        white: whiteOn ? totalWattage : 0
      },
      stepSum,
      embeddedBaseSum: 0, // No embedded base adjustment for single channel
      sharedBase: 0, // No shared base for single channel
      requestedWattage,
      powerLimited,
    };
  }
// For single channels, use step wattage directly (no embedded base manipulation) ********************************** */



  // For multi-channel combinations, use embedded base + shared base approach
  // Step 1: Subtract embedded base values from each active channel
  const sharedBase = calculateBase(red, green, blue, white);
  const redBase = calculateBase(red, 0, 0, 0);
  const greenBase = calculateBase(0, green, 0, 0);
  const blueBase = calculateBase(0, 0, blue, 0);
  const whiteBase = calculateBase(0, 0, 0, white);
  const adjustedWattages = {
    red: redOn ? Math.max(0, stepWattages.red) : 0,
    green: greenOn ? Math.max(0, stepWattages.green) : 0,
    blue: blueOn ? Math.max(0, stepWattages.blue) : 0,
    white: whiteOn ? Math.max(0, stepWattages.white) : 0
  };

  const embeddedBaseSum = adjustedWattages.red + adjustedWattages.green + adjustedWattages.blue + adjustedWattages.white;

  // Step 2: Calculate shared base value based on active channels and intensity


  // Step 3: Total = adjusted wattages + shared base
  requestedWattage = embeddedBaseSum + sharedBase;

  // Apply 138W power limiting
  const MAX_TOTAL_WATTAGE = 138;
  const totalWattage = Math.min(Math.round(requestedWattage), MAX_TOTAL_WATTAGE);
  const powerLimited = requestedWattage > MAX_TOTAL_WATTAGE;

  // Calculate proportional channel contributions for display
  const channelWattages = stepSum > 0 ? {
    red: Math.round((stepWattages.red / stepSum) * totalWattage),
    green: Math.round((stepWattages.green / stepSum) * totalWattage),
    blue: Math.round((stepWattages.blue / stepSum) * totalWattage),
    white: Math.round((stepWattages.white / stepSum) * totalWattage)
  } : { red: 0, green: 0, blue: 0, white: 0 };

  // Ensure the sum matches total (handle rounding)
  const channelSum = channelWattages.red + channelWattages.green + channelWattages.blue + channelWattages.white;
  if (channelSum !== totalWattage && totalWattage > 0) {
    const diff = totalWattage - channelSum;
    if (red > 0) channelWattages.red += diff;
    else if (green > 0) channelWattages.green += diff;
    else if (blue > 0) channelWattages.blue += diff;
    else if (white > 0) channelWattages.white += diff;
  }


  return {
    totalWattage,
    channelWattages,
    stepSum: Math.round(stepSum),
    embeddedBaseSum: Math.round(embeddedBaseSum),
    sharedBase: Math.round(sharedBase),
    requestedWattage: Math.round(requestedWattage),
    powerLimited,
  };
}


/**
 * Gets the maximum possible wattage for WRGB Pro II (actual device limit)
 */
export function getMaxWattage(): number {
  return 138; // Actual device power limit
}

/**
 * Gets the theoretical maximum wattage if there were no power limiting
 */
export function getTheoreticalMaxWattage(): number {
  // Calculate theoretical max: Red:45W + Green:60W + Blue:31W + White:31W = 167W
  return 45 + 60 + 31 + 31;
}



/**
 * Formats wattage for display
 */
export function formatWattage(wattage: number): string {
  return `${wattage}W`;
}
