import { WRGB_PRO_II_WATTAGE_DATA, ChannelWattageData } from './wattage-data';

export interface ChannelPercentages {
  red: number;
  green: number;
  blue: number;
  white: number;
}

export interface WattageCalculationResult {
  totalWattage: number;
  channelWattages: {
    red: number;
    green: number;
    blue: number;
    white: number;
  };
  stepSum: number;
  embeddedBaseSum: number;
  sharedBase: number;
  requestedWattage: number; // What the channels would use without power limiting
  powerLimited: boolean; // Whether power limiting was applied
}


/**
 * Converts a percentage string (e.g., "75%") to a number (e.g., 75)
 */
function parsePercentage(percentageStr: string): number {
  return parseInt(percentageStr.replace('%', ''), 10);
}

/**
 * Calculates the step wattage for a single channel based on its percentage
 * Uses floor lookup: finds the largest percentage in step table â‰¤ input percentage
 */
function calculateChannelStepWattage(channel: 'Red' | 'Green' | 'Blue' | 'White', percentage: number): number {
    if (percentage === 0) return 0;

    const data = WRGB_PRO_II_WATTAGE_DATA[channel];
    if (!data) return 0;

    // Find exact match first
    for (let i = 0; i < data.Percentage.length; i++) {
        const stepPercentage = parseInt(data.Percentage[i].replace('%', ''));
        if (stepPercentage === percentage) {
            return data.Wattage[i];
        }
    }

    // Find the floor step (largest step <= percentage)
    let floorIndex = -1;
    for (let i = 0; i < data.Percentage.length; i++) {
        const stepPercentage = parseInt(data.Percentage[i].replace('%', ''));
        if (stepPercentage <= percentage) {
            floorIndex = i;
        } else {
            break; // Stop when we exceed the target percentage
        }
    }

    // Handle edge cases
    if (floorIndex === -1) {
        return data.Wattage[0]; // Below first point, use first value
    }

    return data.Wattage[floorIndex]; // Use floor step value
}/**
 * Determines shared base value based on which channels are ON
 * Calibrated against real-world measurements from Percentages.txt
 */

// Embedded base values for each channel (constants)
const EMBEDDED_BASE_VALUES = {
  Red: 10,
  Green: 9,
  Blue: 10,
  White: 9
};

function calculateSharedBase(red: number, green: number, blue: number, white: number): number {
  const intensityFactor = 3;
  const redOn = red > 0;
  const greenOn = green > 0;
  const blueOn = blue > 0;
  const whiteOn = white > 0;
  const numOn = (redOn ? 1 : 0) + (greenOn ? 1 : 0) + (blueOn ? 1 : 0) + (whiteOn ? 1 : 0);
  let sharedBase: number = 8;
  if (numOn <= 3) {
    sharedBase += 1;
  }
  if (numOn === 2 ) {
    sharedBase += 2;
  }
  if (whiteOn) {
    sharedBase += 1;
  }
  if (!whiteOn && numOn > 2) {
    sharedBase += 0;
  }
  if (!greenOn && numOn > 2) {
    sharedBase += -1;
  } else {
    sharedBase += 0;
  }

  // Need to factor in active channels affecting intensity.
  const avgIntensity =  1 - ((red + green + blue + white) / (numOn * 100));
  const intensityAdjustment = (intensityFactor*avgIntensity);
/*   if ((red + green + blue + white) / (numOn * 100) >=1 && numOn >= 4 ) {
    sharedBase -= 1;
  } */
  return sharedBase + intensityAdjustment;

}


export function calculateLightWattage(channels: ChannelPercentages): WattageCalculationResult {
  const { red, green, blue, white } = channels;

  // Convert to 0-1 range and determine which channels are active
  const redNormalized = Math.max(0, Math.min(1, red / 100));
  const greenNormalized = Math.max(0, Math.min(1, green / 100));
  const blueNormalized = Math.max(0, Math.min(1, blue / 100));
  const whiteNormalized = Math.max(0, Math.min(1, white / 100));

  const redOn = redNormalized > 0;
  const greenOn = greenNormalized > 0;
  const blueOn = blueNormalized > 0;
  const whiteOn = whiteNormalized > 0;
  const activeChannels = [redOn, greenOn, blueOn, whiteOn].filter(Boolean).length;

  if (activeChannels === 0) {
    return {
      totalWattage: 0,
      channelWattages: { red: 0, green: 0, blue: 0, white: 0 },
      stepSum: 0,
      embeddedBaseSum: 0,
      sharedBase: 0,
      requestedWattage: 0,
      powerLimited: false,
    };
  }

  // Get step wattages from lookup tables (true single-channel values using floor logic)
  const stepWattages = {
    red: redOn ? calculateChannelStepWattage('Red', red) : 0,
    green: greenOn ? calculateChannelStepWattage('Green', green) : 0,
    blue: blueOn ? calculateChannelStepWattage('Blue', blue) : 0,
    white: whiteOn ? calculateChannelStepWattage('White', white) : 0
  };

  let requestedWattage: number;
  const stepSum = stepWattages.red + stepWattages.green + stepWattages.blue + stepWattages.white;

  // For single channels, use step wattage directly (no embedded base manipulation)
  if (activeChannels === 1) {
    requestedWattage = stepSum; // Just the single channel's step wattage

    // Apply 138W power limiting
    const MAX_TOTAL_WATTAGE = 138;
    const totalWattage = Math.min(Math.round(requestedWattage), MAX_TOTAL_WATTAGE);
    const powerLimited = requestedWattage > MAX_TOTAL_WATTAGE;

    return {
      totalWattage,
      channelWattages: {
        red: redOn ? totalWattage : 0,
        green: greenOn ? totalWattage : 0,
        blue: blueOn ? totalWattage : 0,
        white: whiteOn ? totalWattage : 0
      },
      stepSum,
      embeddedBaseSum: 0, // No embedded base adjustment for single channel
      sharedBase: 0, // No shared base for single channel
      requestedWattage,
      powerLimited,
    };
  }

  // For multi-channel combinations, use embedded base + shared base approach
  // Step 1: Subtract embedded base values from each active channel
  const adjustedWattages = {
    red: redOn ? Math.max(0, stepWattages.red - EMBEDDED_BASE_VALUES.Red) : 0,
    green: greenOn ? Math.max(0, stepWattages.green - EMBEDDED_BASE_VALUES.Green) : 0,
    blue: blueOn ? Math.max(0, stepWattages.blue - EMBEDDED_BASE_VALUES.Blue) : 0,
    white: whiteOn ? Math.max(0, stepWattages.white - EMBEDDED_BASE_VALUES.White) : 0
  };

  const embeddedBaseSum = adjustedWattages.red + adjustedWattages.green + adjustedWattages.blue + adjustedWattages.white;

  // Step 2: Calculate shared base value based on active channels and intensity
  const sharedBase = calculateSharedBase(red, green, blue, white);

  // Step 3: Total = adjusted wattages + shared base
  requestedWattage = embeddedBaseSum + sharedBase;

  // Apply 138W power limiting
  const MAX_TOTAL_WATTAGE = 138;
  const totalWattage = Math.min(Math.round(requestedWattage), MAX_TOTAL_WATTAGE);
  const powerLimited = requestedWattage > MAX_TOTAL_WATTAGE;

  // Calculate proportional channel contributions for display
  const channelWattages = stepSum > 0 ? {
    red: Math.round((stepWattages.red / stepSum) * totalWattage),
    green: Math.round((stepWattages.green / stepSum) * totalWattage),
    blue: Math.round((stepWattages.blue / stepSum) * totalWattage),
    white: Math.round((stepWattages.white / stepSum) * totalWattage)
  } : { red: 0, green: 0, blue: 0, white: 0 };

  // Ensure the sum matches total (handle rounding)
  const channelSum = channelWattages.red + channelWattages.green + channelWattages.blue + channelWattages.white;
  if (channelSum !== totalWattage && totalWattage > 0) {
    const diff = totalWattage - channelSum;
    if (red > 0) channelWattages.red += diff;
    else if (green > 0) channelWattages.green += diff;
    else if (blue > 0) channelWattages.blue += diff;
    else if (white > 0) channelWattages.white += diff;
  }


  return {
    totalWattage,
    channelWattages,
    stepSum: Math.round(stepSum),
    embeddedBaseSum: Math.round(embeddedBaseSum),
    sharedBase: Math.round(sharedBase),
    requestedWattage: Math.round(requestedWattage),
    powerLimited,
  };
}


/**
 * Gets the maximum possible wattage for WRGB Pro II (actual device limit)
 */
export function getMaxWattage(): number {
  return 138; // Actual device power limit
}

/**
 * Gets the theoretical maximum wattage if there were no power limiting
 */
export function getTheoreticalMaxWattage(): number {
  // Calculate theoretical max: Red:45W + Green:60W + Blue:31W + White:31W = 167W
  return 45 + 60 + 31 + 31;
}



/**
 * Formats wattage for display
 */
export function formatWattage(wattage: number): string {
  return `${wattage}W`;
}
