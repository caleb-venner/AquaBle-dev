# Frontend Implementation Guide: Device State Management

This document outlines the strategy for the frontend to load, interpret, and display device settings from the backend. The goal is to ensure the UI correctly reflects both saved configurations and live device status, especially after server restarts or device reconnections.

## 1. Core Concepts

The backend separates a device's state into two distinct categories:

1.  **Saved Configuration**: The user's *intended* setup (e.g., dosing schedules, lighting profiles). This data is persistent and represents the "source of truth" for how the user wants the device to behave.
2.  **Live Status**: A real-time snapshot of the device's operational state (e.g., is it connected? what is the current brightness?). This data is volatile and reflects the "live reality".

The frontend's primary task is to fetch and correctly display information from these sections.

## 2. Data Loading on Application Start

A two-stage loading process is recommended to provide a fast and responsive user experience.

### Stage 1: Fetch Saved Configurations

As soon as the application loads, make parallel API calls to get all persistent, saved configurations.

1.  **`GET /api/configurations/dosers`**: Returns a `List[DoserDevice]`.
2.  **`GET /api/configurations/lights`**: Returns a `List[LightDevice]`.

**What to do with this data:**

- Use this data to **immediately render the main structure of the device cards**.
- Use the `name` field from each `DoserDevice` or `LightDevice` object for the card's title.
- To find the correct schedule/profile to display, use the `activeConfigurationId` to select the active configuration from the `configurations` list.
- From that active configuration, use the **last revision** in the `revisions` list. This is the most up-to-date version of the user's settings.

This ensures the UI is populated instantly with the user's saved settings, even if the physical devices are offline.

#### Example Data Structure (`DoserDevice`)

```json
{
  "id": "AA:BB:CC:DD:EE:FF",
  "name": "My Doser", // Use this for the card title
  "activeConfigurationId": "config-1", // Find this ID in the list below
  "configurations": [
    {
      "id": "config-1",
      "name": "Daily Dosing",
      "revisions": [
        { "revision": 1, "heads": [...] },
        { "revision": 2, "heads": [...] } // Use this latest revision
      ]
    }
  ]
}
```

### Stage 2: Fetch Live Status

After the initial render, make a single API call to get the last known live status for all devices from the backend's in-memory cache.

- **`GET /api/status`**

**What to do with this data:**

- This endpoint returns a dictionary where keys are device addresses and values are serialized `CachedStatus` objects.
- This response is generated by the `cached_status_to_dict` serializer, which adds a crucial `connected: bool` flag.
- Use this data to overlay live information onto the already-rendered device cards.

#### Example Response (`GET /api/status`)

```json
{
  "AA:BB:CC:DD:EE:FF": {
    "address": "AA:BB:CC:DD:EE:FF",
    "device_type": "doser",
    "connected": true, // Key flag for UI status badge
    "parsed": {
      "power": "on",
      "mlDispensedToday": [5.5, 6.0, 0, 0] // Live data
    },
    "updated_at": 1677614400.0 // For "Last seen" messages
  }
}
```

## 3. Saving User Changes

When a user modifies a device's configuration (e.g., changes a dosing schedule, updates a light profile), the frontend must save this back to the backend. This is typically done by creating a **new revision** of the active configuration.

1.  **Read**: Fetch the full device configuration using `GET /api/configurations/dosers/{address}`.
2.  **Modify**: In the frontend's state, create a new `ConfigurationRevision` object with the user's changes. Increment the `revision` number and add it to the `revisions` list of the active configuration.
3.  **Write**: Send the entire modified `DoserDevice` or `LightDevice` object back to the backend using a `PUT` request.
    - `PUT /api/configurations/dosers/{address}`
    - `PUT /api/configurations/lights/{address}`

The backend will handle the logic of saving the new revision to the device's JSON file.

## 4. Real-Time Updates

The `BLEService` in the backend automatically attempts to reconnect to known devices. As devices come online, their status changes.

To reflect these changes in real-time, the frontend should:

- **Establish a WebSocket connection** to the backend. The backend will push status updates over this connection whenever a device connects, disconnects, or sends new data.
- **Alternatively (for initial implementation)**, the frontend can periodically poll the `GET /api/status` endpoint to refresh the live state of all devices.

This approach ensures the UI is always populated with the most complete data available, gracefully handling the transition from a disconnected to a connected state without the user losing context or their saved settings.
